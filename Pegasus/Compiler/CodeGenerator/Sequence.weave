{{
    var finalResultName = (string)model.FinalResultName;
    var finalResultType = (object)model.FinalResultType;
    var index = (int)model.Index;
    var sequence = (IList<Expression>)model.Sequence;
    var startCursorName = (string)model.StartCursorName;

    var expression = sequence[index];

    var codeExpression = expression as CodeExpression;
    if (codeExpression != null && codeExpression.CodeType == CodeType.State)
    {
        codeExpression = null;
    }
}}
{{if expression == null}}
    var len = cursor.Location - {{: startCursorName }}.Location;
    {{: finalResultName }} = this.ReturnHelper<{{= finalResultType }}>({{: startCursorName }}, ref cursor, state =>
        state.Subject.Substring({{: startCursorName }}.Location, len)
        );
{{elif codeExpression != null}}
    {{if codeExpression.CodeType == CodeType.Result}}
        {{: finalResultName }} = this.ReturnHelper<{{= finalResultType }}>({{: startCursorName }}, ref cursor, state =>
            {{@RenderCode codeExpression.CodeSpan}}
            );
    {{elif codeExpression.CodeType == CodeType.Error}}
        throw this.ExceptionHelper({{: startCursorName }}, state =>
            {{@RenderCode codeExpression.CodeSpan}}
            );
    {{/if}}
{{else}}
    {{
        this.currentResultName = this.CreateVariable("r");
        this.currentResultType = this.types[expression];
    }}
    {{if this.currentResultType is CodeSpan}}
        IParseResult<
            {{@RenderCode this.currentResultType}}
            > {{: this.currentResultName }} = null;
    {{else}}
        IParseResult<{{= this.currentResultType }}> {{: this.currentResultName }} = null;
    {{/if}}
    {{@WalkExpression expression}}
    if ({{: this.currentResultName }} != null)
    {
        {{@RenderSequence new { FinalResultName = finalResultName, FinalResultType = finalResultType, Index = index + 1, Sequence = sequence, StartCursorName = startCursorName } }}
    }
    else
    {
        cursor = {{: startCursorName }};
    }
{{/if}}