{
    using System.Linq;
    using Pegasus.Expressions;
}

grammar
  = <Grammar> __ initializer:initializer? rules:rule+ {
        return new Grammar(
            rules: rules.Value,
            initializer: initializer.Value.SingleOrDefault());
    }

initializer
  = code:action semicolon? {
        return code.Value;
    }

rule
  = <Rule> name:identifier displayName:string? equals expression:expression semicolon? {
        return new Rule(
            name: name.Value,
            displayName: displayName.Value.SingleOrDefault(),
            expression: expression.Value);
    }

expression
  = <Expression> type:type? choice:choice {
        var typeValue = type.Value.SingleOrDefault();
        return typeValue != null
            ? new TypedExpression(typeValue, choice.Value)
            : choice.Value;
    }

type
  = lt dotted:dotted gt {
        return dotted.Value;
    }

choice
  = <Expression> head:sequence tail:(<Expression> slash sequence:sequence { return sequence.Value; })* {
        if (tail.Value.Count == 0)
        {
            return head.Value;
        }
        else
        {
            return (Expression)new SequenceExpression(new [] { head.Value }.Concat(tail.Value));
        }
    }

sequence
  = <Expression> elements:labeled* code:action {
        return (Expression)new SequenceExpression(elements.Value.Concat(new Expression[] { new CodeExpression(code.Value) }));
    }
  / elements:labeled* {
        if (elements.Value.Count == 1)
        {
            return elements.Value[0];
        }
        else
        {
            return new SequenceExpression(elements.Value);
        }
    }

labeled
  = <Expression> label:identifier colon expression:prefixed {
        return (Expression)new PrefixedExpression(label.Value, expression.Value);
    }
  / prefixed

prefixed
  = <Expression> and expression:suffixed {
        return (Expression)new AndExpression(expression.Value);
    }
  / not expression:suffixed {
        return (Expression)new NotExpression(expression.Value);
    }
  / suffixed

suffixed
  = <Expression> expression:primary question {
        return (Expression)new RepetitionExpression(expression.Value, min: 0, max: 1);
    }
  / expression:primary star {
        return (Expression)new RepetitionExpression(expression.Value, min: 0, max: null);
    }
  / expression:primary plus {
        return (Expression)new RepetitionExpression(expression.Value, min: 1, max: null);
    }
  / primary

primary
  = <Expression> name:identifier !(string? equals) {
        return (Expression)new NameExpression(name.Value);
    }
  / literal
  / class
  / dot { return (Expression)new WildcardExpression(); }
  / lparen expression:expression rparen { return expression.Value; }

/* "Lexical" elements */

action "action"
  = braced:braced __ { return braced.Value.Substring(1, braced.Value.Length - 2); }

braced
  = "{" parts:(braced / nonBraceCharacters)* "}"

nonBraceCharacters
  = chars:nonBraceCharacter+ { return string.Join("", chars.Value); }

nonBraceCharacter
  = [^{}]

equals    = "=" __ { return "="; }
colon     = ":" __ { return ":"; }
semicolon = ";" __ { return ";"; }
slash     = "/" __ { return "/"; }
and       = "&" __ { return "&"; }
not       = "!" __ { return "!"; }
question  = "?" __ { return "?"; }
star      = "*" __ { return "*"; }
plus      = "+" __ { return "+"; }
lparen    = "(" __ { return "("; }
rparen    = ")" __ { return ")"; }
dot       = "." __ { return "."; }
lt        = "<" __ { return "."; }
gt        = ">" __ { return "."; }

/*
 * Modeled after ECMA-262, 5th ed., 7.6, but much simplified:
 *
 * * no Unicode escape sequences
 *
 * * "Unicode combining marks" and "Unicode connection punctuation" can't be
 *   part of the identifier
 *
 * * only [a-zA-Z] is considered a "Unicode letter"
 *
 * * only [0-9] is considered a "Unicode digit"
 *
 * The simplifications were made just to make the implementation little bit
 * easier, there is no "philosophical" reason behind them.
 */
identifier "identifier"
  = head:(letter / "_" / "$") tail:(letter / digit / "_" / "$")* __ {
        return head.Value + string.Join("", tail.Value);
    }

dotted "dotted identifier"
  = segment (dot segment)*

segment
  = identifier (lt dotted gt)?

/*
 * Modeled after ECMA-262, 5th ed., 7.8.4. (syntax & semantics, rules only
 * vaguely).
 */
literal "literal"
  = <Expression> value:(doubleQuotedString / singleQuotedString) flags:"i"? __ {
        return (Expression)new LiteralExpression(value.Value, ignoreCase: flags.Value.SingleOrDefault() == "i");
    }

string "string"
  = string:(doubleQuotedString / singleQuotedString) __ { return @string.Value; }

doubleQuotedString
  = '"' chars:doubleQuotedCharacter* '"' { return string.Join("", chars.Value); }

doubleQuotedCharacter
  = simpleDoubleQuotedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence

simpleDoubleQuotedCharacter
  = !('"' / "\\" / eolChar) char_:. { return char_.Value; }

singleQuotedString
  = "'" chars:singleQuotedCharacter* "'" { return string.Join("", chars.Value); }

singleQuotedCharacter
  = simpleSingleQuotedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence

simpleSingleQuotedCharacter
  = !("'" / "\\" / eolChar) char_:. { return char_.Value; }

class "character class"
  = <Expression> "[" inverted:"^"? parts:(<CharacterRange> classCharacterRange / classCharacter)* "]" flags:"i"? __ {
        return (Expression)new ClassExpression(
            parts.Value,
            negated: inverted.Value.SingleOrDefault() == "^",
            ignoreCase: flags.Value.SingleOrDefault() == "i");
    }

classCharacterRange
  = <CharacterRange> begin:bracketDelimitedCharacter "-" end:bracketDelimitedCharacter {
        return new CharacterRange(begin.Value[0], end.Value[0]);
    }

classCharacter
  = <CharacterRange> char_:bracketDelimitedCharacter {
        return new CharacterRange(char_.Value[0], char_.Value[0]);
    }

bracketDelimitedCharacter
  = simpleBracketDelimitedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence

simpleBracketDelimitedCharacter
  = !("]" / "\\" / eolChar) char_:. { return char_.Value; }

simpleEscapeSequence
  = "\\" !(digit / "x" / "u" / eolChar) char_:. {
        return char_.Value
            .Replace("b", "\b")
            .Replace("f", "\f")
            .Replace("n", "\n")
            .Replace("r", "\r")
            .Replace("t", "\t")
            .Replace("v", "\v");
    }

zeroEscapeSequence
  = "\\0" !digit { return "\x00"; }

hexEscapeSequence
  = "\\x" h1:hexDigit h2:hexDigit {
        return ((char)Convert.ToInt32(h1.Value + h2.Value)).ToString();
    }

unicodeEscapeSequence
  = "\\u" h1:hexDigit h2:hexDigit h3:hexDigit h4:hexDigit {
        return ((char)Convert.ToInt32(h1.Value + h2.Value + h3.Value + h4.Value)).ToString();
    }

eolEscapeSequence
  = "\\" eol:eol { return eol.Value; }

digit
  = [0-9]

hexDigit
  = [0-9a-fA-F]

letter
  = lowerCaseLetter
  / upperCaseLetter

lowerCaseLetter
  = [a-z]

upperCaseLetter
  = [A-Z]

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment "comment"
  = singleLineComment
  / multiLineComment

singleLineComment
  = "//" (!eolChar .)*

multiLineComment
  = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028"
  / "\u2029"

eolChar
  = [\n\r\u2028\u2029]

/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace "whitespace"
  = [ \t\v\f\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]